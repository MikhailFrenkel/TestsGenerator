using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator
{
    public class Generator
    {
        private readonly string _outputDirectory;
        private readonly int _writeCountFiles;
        private readonly int _readCountFiles;
        private readonly int _maxTasks;

        public Generator(string outputDirectory, int readCountFiles, int maxTasks, int writeCountFiles)
        {
            _outputDirectory = outputDirectory;
            _readCountFiles = readCountFiles;
            _maxTasks = maxTasks;
            _writeCountFiles = writeCountFiles;
        }

        public Task Generate(List<string> paths)
        {
            return Task.Run(() =>
            {
                var reader = new TransformBlock<string, string>(new Func<string, string>(ReadFile),
                    new ExecutionDataflowBlockOptions {MaxDegreeOfParallelism = _readCountFiles});

                var generator = new TransformBlock<string, List<GeneratedResult>>(
                    new Func<string, List<GeneratedResult>>(GenerateFile),
                    new ExecutionDataflowBlockOptions {MaxDegreeOfParallelism = _maxTasks});

                var writer = new ActionBlock<List<GeneratedResult>>(new Action<List<GeneratedResult>>(WriteFile),
                    new ExecutionDataflowBlockOptions {MaxDegreeOfParallelism = _writeCountFiles});

                var linkOptions = new DataflowLinkOptions {PropagateCompletion = true};

                reader.LinkTo(generator, linkOptions);
                generator.LinkTo(writer, linkOptions);

                foreach (var path in paths) reader.Post(path);

                reader.Complete();

                writer.Completion.Wait();
            });
        }

        private string ReadFile(string path)
        {
            return File.ReadAllText(path);
        }

        private List<GeneratedResult> GenerateFile(string source)
        {
            var res = new List<GeneratedResult>();

            var syntaxTree = CSharpSyntaxTree.ParseText(source);
            var compilationUnitSyntax = syntaxTree.GetCompilationUnitRoot();

            var classes = compilationUnitSyntax.DescendantNodes().OfType<ClassDeclarationSyntax>();

            foreach (var classDeclaration in classes)
            {
                var publicMethods = classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(x => x.Modifiers.Any(y => y.ValueText == "public"));

                var ns = (classDeclaration.Parent as NamespaceDeclarationSyntax)?.Name.ToString();
                var className = classDeclaration.Identifier.ValueText;
                var methodsName = new List<string>();
                foreach (var method in publicMethods)
                {
                    var name = GetMethodName(methodsName, method.Identifier.ToString(), 0);
                    methodsName.Add(name);
                }

                //todo: генерация использовать roslyn

                /*var outputFile = "using Microsoft.VisualStudio.TestTools.UnitTesting;\n\n"
                                 + "namespace " + ns + ".Test\n{\n\t[TestClass]\n\tpublic class "
                                 + className + "Test\n\t{";

                foreach (var method in methodsName)
                {
                    outputFile += "\n\t\t[TestMethod]\n\t\tpublic void " + method
                                                                         + "Test()\n\t\t{\n\t\t\tAssert.Fail(\"autogenerated\");\n\t\t}";
                }

                outputFile += "\n\t}\n}";    */

                NamespaceDeclarationSyntax namespaceDeclarationSyntax = NamespaceDeclaration(QualifiedName(
                    IdentifierName(ns), IdentifierName("Test")));

                CompilationUnitSyntax compilationUnit = CompilationUnit()
                    .WithUsings(GetUsings())
                    .WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclarationSyntax
                        .WithMembers(SingletonList<MemberDeclarationSyntax>(ClassDeclaration(className + "Tests")
                            .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestClass"))))))
                            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                            .WithMembers(GetMethods(methodsName))))));

                

                var outputPath = Path.Combine(_outputDirectory, className + "Test.cs");//_outputDirectory + "/" + className + "Test.cs";
                res.Add(new GeneratedResult
                {
                    Text = compilationUnit.NormalizeWhitespace().ToFullString(),
                    OutputPath = outputPath
                });
            }

            return res;
        }

        private void WriteFile(List<GeneratedResult> results)
        {
            foreach (var result in results) File.WriteAllText(result.OutputPath, result.Text);
        }

        private SyntaxList<UsingDirectiveSyntax> GetUsings()
        {
            return new SyntaxList<UsingDirectiveSyntax>()
            {
                UsingDirective(
                    QualifiedName(
                        QualifiedName(
                            QualifiedName(
                                IdentifierName("Microsoft"),
                                IdentifierName("VisualStudio")),
                            IdentifierName("TestTools")),
                        IdentifierName("UnitTesting")))
            };
        }

        private SyntaxList<MemberDeclarationSyntax> GetMethods(List<string> methods)
        {
            var result = new List<MemberDeclarationSyntax>();
            foreach (var method in methods) result.Add(GetMethod(method));

            return List(result);
        }

        private MethodDeclarationSyntax GetMethod(string name)
        {
            /*return MethodDeclaration(
                PredefinedType(Token(SyntaxKind.VoidKeyword)), IdentifierName(name))
                .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(
                    Attribute(IdentifierName("TestMethod"))))))
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithBody(Block((ExpressionStatement(InvocationExpression(
                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName("Assert"), IdentifierName("Fail")))))));*/

            return MethodDeclaration(
                    PredefinedType(Token(SyntaxKind.VoidKeyword)),Identifier(name))
                .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(
                                Attribute(IdentifierName("TestMethod"))))))
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithBody(Block(ExpressionStatement(InvocationExpression(
                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName("Assert"), IdentifierName("Fail"))))));
        }

        private string GetMethodName(List<string>methods, string method, int count)
        {
            var res = method + (count == 0 ? "" : count.ToString());
            if (methods.Contains(res)) return GetMethodName(methods, method, count + 1);

            return res;
        }
    }

    internal class GeneratedResult
    {
        public string Text { get; set; }
        public string OutputPath { get; set; }
    }
}
