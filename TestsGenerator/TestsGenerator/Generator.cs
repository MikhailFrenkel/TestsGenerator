using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TestsGenerator
{
    public class Generator
    {
        private readonly string _outputDirectory;
        private readonly int _writeCountFiles;
        private readonly int _readCountFiles;
        private readonly int _maxTasks;
        private readonly List<string> _sources;
        private readonly List<GeneratedResult> _results;

        public Generator(string outputDirectory, int readCountFiles, int maxTasks, int writeCountFiles)
        {
            _outputDirectory = outputDirectory;
            _readCountFiles = readCountFiles;
            _maxTasks = maxTasks;
            _writeCountFiles = writeCountFiles;
            _sources = new List<string>();
            _results = new List<GeneratedResult>();
        }

        public void Generate(List<string> paths)
        {
            /*Parallel.ForEach(paths, new ParallelOptions {MaxDegreeOfParallelism = _readCountFiles},
                path => { _sources.Add(ReadFile(path)); });

            Parallel.ForEach(_sources, new ParallelOptions {MaxDegreeOfParallelism = _maxTasks},
                source => { _results.AddRange(GenerateFile(source)); });

            Parallel.ForEach(_results, new ParallelOptions {MaxDegreeOfParallelism = _writeCountFiles},
                WriteFile);*/

            var reader = new TransformBlock<string, string>(new Func<string, string>(ReadFile), 
                new ExecutionDataflowBlockOptions{ MaxDegreeOfParallelism = _readCountFiles });

            var generator = new TransformBlock<string, List<GeneratedResult>>(new Func<string, List<GeneratedResult>> (GenerateFile),
                new ExecutionDataflowBlockOptions {MaxDegreeOfParallelism = _maxTasks});

            var writer = new ActionBlock<List<GeneratedResult>>(new Action<List<GeneratedResult>>(WriteFile),
                new ExecutionDataflowBlockOptions {MaxDegreeOfParallelism = _writeCountFiles});

            var linkOptions = new DataflowLinkOptions { PropagateCompletion = true };

            reader.LinkTo(generator, linkOptions);
            //reader.Completion.ContinueWith(x => generator.Complete());
            generator.LinkTo(writer, linkOptions);
            //generator.Completion.ContinueWith(x => writer.Complete());

           // Parallel.ForEach(paths, async path => { await read.SendAsync(path); });

            foreach (var path in paths)
            {
                reader.Post(path);
            }

            reader.Complete();

            writer.Completion.Wait();
            //todo: Propagate changes
            //while (!write.Completion.IsCompleted);*/
        }

        private string ReadFile(string path)
        {
            return File.ReadAllText(path);
        }

        private List<GeneratedResult> GenerateFile(string source)
        {
            List<GeneratedResult> res = new List<GeneratedResult>();

            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);
            CompilationUnitSyntax compilationUnitSyntax = syntaxTree.GetCompilationUnitRoot();

            var classes = compilationUnitSyntax.DescendantNodes().OfType<ClassDeclarationSyntax>();

            foreach (var classDeclaration in classes)
            {
                var publicMethods = classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(x => x.Modifiers.Any(y => y.ValueText == "public"));

                string ns = (classDeclaration.Parent as NamespaceDeclarationSyntax)?.Name.ToString();
                string className = classDeclaration.Identifier.ValueText;
                List<string> methodsName = new List<string>();
                foreach (var method in publicMethods)
                {
                    var name = GetMethodName(methodsName, method.Identifier.ToString(), 0);
                    methodsName.Add(name);
                }

                //todo: генерация использовать roslyn

                var outputFile = "using Microsoft.VisualStudio.TestTools.UnitTesting;\n\n"
                                 + "namespace " + ns + ".Test\n{\n\t[TestClass]\n\tpublic class "
                                 + className + "Test\n\t{";

                foreach (var method in methodsName)
                {
                    outputFile += "\n\t\t[TestMethod]\n\t\tpublic void " + method
                                                                         + "Test()\n\t\t{\n\t\t\tAssert.Fail(\"autogenerated\");\n\t\t}";
                }

                outputFile += "\n\t}\n}";

                var outputPath = Path.Combine(_outputDirectory, className + "Test.cs");//_outputDirectory + "/" + className + "Test.cs";
                res.Add(new GeneratedResult
                {
                    Text = outputFile,
                    OutputPath = outputPath
                });
            }

            return res;
        }

        private void WriteFile(List<GeneratedResult> results)
        {
            foreach (var result in results)
            {
                File.WriteAllText(result.OutputPath, result.Text);
            }            
        }
        
        private string GetMethodName(List<string>methods, string method, int count)
        {
            string res = method + (count == 0 ? "" : count.ToString());
            if (methods.Contains(res))
            {
                return GetMethodName(methods, method, count + 1);
            }

            return res;
        }
    }

    class GeneratedResult
    {
        public string Text { get; set; }
        public string OutputPath { get; set; }
    }
}
